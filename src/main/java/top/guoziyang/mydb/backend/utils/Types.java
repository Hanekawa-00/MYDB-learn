package top.guoziyang.mydb.backend.utils;

/**
 * Types - 类型转换和地址计算工具类
 * 
 * 这个类提供了MYDB系统中特定的数据类型转换功能，主要用于
 * 将页号和页内偏移量组合成唯一的地址标识符。这种地址编码
 * 方式在数据库系统中非常常见，用于唯一标识数据的物理位置。
 * 
 * 与MySQL的对比：
 * - InnoDB使用类似的概念来标识数据页中的记录位置
 * - MySQL的行ID（ROW_ID）也是一种地址编码方式
 * - InnoDB的B+树叶子节点存储的是数据页地址+页内偏移
 * - 聚簇索引的辅助索引记录包含主键值，也是一种地址引用
 * - MYDB简化了这一概念，使用64位长整型统一表示地址
 * 
 * 地址编码格式：
 * - 高32位：页号（Page Number）
 * - 低32位：页内偏移量（Offset）
 * - 总共64位，能够表示非常大的地址空间
 * 
 * 设计优势：
 * 1. 统一地址表示：所有数据位置都用一个long值表示
 * 2. 高效访问：可以快速从地址中提取页号和偏移量
 * 3. 节省空间：比使用两个独立的int更节省空间
 * 4. 唯一性：在整个数据库中每个位置都有唯一标识
 * 
 * 应用场景：
 * 1. 数据记录的物理地址标识
 * 2. 索引中指向数据页的指针
 * 3. 日志记录中的数据位置引用
 * 4. 缓存管理中的数据定位
 * 5. 数据恢复时的位置追踪
 */
public class Types {
    
    /**
     * 将页号和页内偏移量组合成唯一地址标识符
     * 
     * 这个方法实现了MYDB的地址编码算法，将两个32位的值
     * 组合成一个64位的唯一标识符。
     * 
     * 编码算法详解：
     * 1. 将页号（int）转换为long类型，占用低32位
     * 2. 将页号左移32位，移动到高32位位置
     * 3. 将偏移量（short）转换为long类型，占用低16位
     * 4. 使用位或运算（|）将两部分组合
     * 
     * 位布局示例：
     * ```
     * 原始数据：
     * pgno = 0x12345678 (页号)
     * offset = 0x9ABC   (偏移量)
     * 
     * 编码过程：
     * u0 = 0x0000000012345678 (页号转long)
     * u0 << 32 = 0x1234567800000000 (左移32位)
     * u1 = 0x0000000000009ABC (偏移量转long)
     * 
     * 最终结果：
     * uid = 0x1234567800009ABC
     * ```
     * 
     * 与MySQL地址方案的对比：
     * - InnoDB的页内记录指针使用2字节偏移量
     * - MySQL的ROWID使用6字节（48位）表示物理位置
     * - MYDB使用8字节（64位）提供更大的地址空间
     * - 编码方式相似，都是高位存页号，低位存偏移
     * 
     * 解码方法（供参考）：
     * ```java
     * // 从UID中提取页号
     * int pageNo = (int)(uid >>> 32);
     * 
     * // 从UID中提取偏移量
     * short offset = (short)(uid & 0xFFFF);
     * ```
     * 
     * 使用注意事项：
     * 1. 页号必须是非负数（实际使用31位）
     * 2. 偏移量必须在short范围内（0-65535）
     * 3. 生成的UID在整个数据库中必须唯一
     * 4. 不能使用0作为有效地址（通常表示空地址）
     * 
     * 典型使用场景：
     * ```java
     * // 在数据页中插入记录后获得地址
     * int pageNumber = 100;        // 第100页
     * short recordOffset = 256;    // 页内偏移256字节
     * long recordUID = Types.addressToUid(pageNumber, recordOffset);
     * 
     * // 将地址存储到索引中
     * index.insert(key, recordUID);
     * 
     * // 根据地址读取数据
     * DataItem item = dataManager.read(recordUID);
     * ```
     * 
     * @param pgno   页号，表示数据所在的页面编号（0-2^31-1）
     * @param offset 页内偏移量，表示在页面中的字节偏移（0-65535）
     * @return 组合后的唯一地址标识符，高32位是页号，低32位是偏移量
     */
    public static long addressToUid(int pgno, short offset) {
        // 将页号转换为long类型，确保数据类型一致
        long u0 = (long)pgno;
        
        // 将偏移量转换为long类型，确保数据类型一致
        long u1 = (long)offset;
        
        // 页号左移32位到高32位，偏移量保留在低32位，然后进行位或运算
        // 这种编码方式确保了地址的唯一性和可解码性
        return u0 << 32 | u1;
    }
}
